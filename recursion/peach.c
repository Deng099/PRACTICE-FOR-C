/*yoj117

输入样例
32
1
2 3
4 6 5
数字表示当前这条树枝最多能摘到的桃子数（小于100），
在摘得某枝条的桃子之后，小猴子只能选择往左上方爬或者是往右上方爬
（也就是说在摘了有6个桃子的树枝之后只能摘有2个桃子的树枝或是有3个桃子的树枝），然后继续摘桃子。
小猴子现在想要从最低层开始一直爬到树顶（也就是最上面的那个枝条），摘尽可能多的桃子。

输出样例
10


关键思路： 
没有桃子的地方填充0补齐数组

逆向思考。

如果从下而上，就要考虑最左侧是否能够往左上跑（数组越界风险！需分类讨论，麻烦）

而如果自上而下考虑
对于上层位置(i,j)，它可以从下层(i+1,j)或(i+1,j+1)到达
用 上层位置的值 加 从下层到达该上层位置的最大值 作为这个位置的值

这样也不会漏掉所有值，是一种“收束”的感觉

*/



#include <stdio.h>

int main()
{
    int n ;
    scanf ("%d" , &n ) ;

    int peach[100][100] = {0} ;

    int i , j ; 

    //第i+1行，有j+1个数
    for ( i = 0 ; i < n ; i ++ )
    {
        for ( j = 0 ; j <= i ; j ++ )
        {
            scanf ("%d" , &peach[i][j] ) ;
        }
    }

    //输入完成，到peach[][]中


    
    for ( i = n - 2 ; i >= 0 ; i -- )
    {
        for( j = 0 ; j <= i ; j ++ ) 
        {
            peach[i][j] += ( peach[i+1][j] > peach[i+1][j+1] 
                           ? peach[i+1][j] : peach[i+1][j+1] ) ;
        }
    }


    printf ("%d" , peach[0][0] ) ;

}

